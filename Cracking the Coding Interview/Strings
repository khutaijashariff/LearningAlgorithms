public class Strings {

  //Is Unique: Implement an algorithm to determine if a string has all unique characters. What if you cannot use additional data structures?
  
    public boolean checkUniqueCharacters(String s) {
        if(s.length() > 256) {
            return false;
        }
        boolean[] charSet  = new boolean[256];
        for(int i=0; i<s.length(); i++) {
            int index = s.charAt(i);
            if(charSet[index]) {
                return false;
            }
            charSet[index] = true;
        }
        return true;
    }

// Given two strings, write a method to decide if one is a permutation of the other

 public boolean isPermutation(String s1, String s2) {
        if (s1.length() != s2.length()) {
            return false;
        }
        int[] charSet = new int[256];
        for (int i = 0; i < s1.length(); i++) {
            int charIndex = s1.charAt(i);
            charSet[charIndex]++;
        }
        for (int i = 0; i < s2.length(); i++) {
            int charIndex = s2.charAt(i);
            charSet[charIndex]--;
            if (charSet[charIndex] < 0) {
                return false;
            }
        }
        return true;
    }
    
    /**
    *URLify: Write a method to replace all spaces in a string with '%20'. You may assume that the string
    *has sufficient space at the end to hold the additional characters, and that you are given the "true"
    *length of the string. (Note: if implementing in Java, please use a character array so that you can
    *perform this operation in place.)
    */
    
     public void replaceSpaces(char[] s, int length) {
       int actualLength = s.length;
       int actualIterator = actualLength-1;
       for(int i=length-1; i>=0; i--) {
           if(s[i] == ' ') {
               s[actualIterator] = '0';
               s[actualIterator-1] = '2';
               s[actualIterator-2] = '%';
               actualIterator -= 3;
           } else {
               s[actualIterator] =  s[i];
               actualIterator--;
           }
       }
   }
   
   /**
    *Palindrome Permutation: Given a string, write a function to check if it is a permutation of
    *a palindrome. A palindrome is a word or phrase that is the same forwards and backwards. A
    *permutation is a rearrangement of letters. The palindrome does not need to be limited to just
    *dictionary words.
   */
   
    public boolean isPermutationOfPalindrome(String s) {
        String[] stringsArray = s.split("\\s+");
        StringBuilder sb = new StringBuilder();
        for(int i=0; i<stringsArray.length; i++) {
            sb.append(stringsArray[i]);
        }
        String use = sb.toString();
        char[] useArray = use.toCharArray();
        Hashtable<Character, Integer> hash = new Hashtable<Character, Integer>();
        for (char c :useArray) {
            if (hash.containsKey(c)) {
                hash.put(c, hash.get(c) + 1);
            } else {
                hash.put(c, 1);
            }
        }
        if (isEven(s.length())) {
            for (int key : hash.values()) {
                if (!isEven(key)) {
                    return false;
                }
            }
        } else {
            int odd = 0;
            for (int key : hash.values())
                if (!isEven(key)) {
                    odd++;
                    if (odd > 1)
                        return false;
                }
        }
        return true;
    }

    public boolean isEven(int num) {
        if (num % 2 == 0) {
            return true;
        }
        return false;
    }
    
    /**
     *One Away: There are three types of edits that can be performed on strings: insert a character,
     *remove a character, or replace a character. Given two strings, write a function to check if they are
     *one edit (or zero edits) away.
    */
    
     public boolean oneAway(String s1, String s2) {
        if(s1.equals(s2)) {
            return true;
        }else if(s1.length() == s2.length()) {
            return oneReplace(s1, s2);
        }else if(s1.length() == s2.length()+1) {
            return oneInsert(s2, s1);
        }else if(s1.length()+1 == s2.length()) {
            return oneInsert(s1, s2);
        }
        return false;
    }

    public boolean oneReplace(String s1, String s2) {
        int edit = 0;
        for(int i=0, j=0; i<s1.length() && j<s2.length(); i++, j++) {
            if(s1.charAt(i)!=s2.charAt(i)) {
               edit++;
                if(edit>1) {
                    return false;
                }
            }
        }
        return true;
    }

    public boolean oneInsert(String s1, String s2) {
        int i1 = 0;
        int i2 = 0;
        while(i1<s1.length() && i2<s2.length()) {
            if(s1.charAt(i1) != s2.charAt(i2)) {
                if(i1!=i2) {
                    return false;
                }
                i2++;
            }else {
                i1++;
                i2++;
            }
        }
        return true;
    }

    
      public static void main(String[] args) {
        Strings s = new Strings();
        //test unique characters
        String input1 = "terakfjydlighboh";
        boolean result1 = s.checkUniqueCharacters(input1);
       System.out.println(result1);
     }
}
