public class Tree {

//Minimal Tree: Given a sorted (increasing order) array with unique integer elements, write an
algorithm to create a binary search tree with minimal height.

 public TreeNode createMinimalTree(int[] arr) {
       return createMinimalTree(arr, 0, arr.length-1);

    }

    public TreeNode createMinimalTree(int[] arr, int low, int high) {
        if(low>high) {
            return null;
        }
        int mid = (high+low)/2;
        TreeNode n = new TreeNode(arr[mid]);
        n.left = createMinimalTree(arr, low, mid-1);
        n.right = createMinimalTree(arr, mid+1, high);
        return n;
    }
    
    
//Given a binary tree, design an algorithm which creates a linked list of all the nodes
at each depth

public ArrayList<LinkedList<TreeNode>> linkedListForDepth() {
        ArrayList<LinkedList<TreeNode>> result =new ArrayList<LinkedList<TreeNode>>();
        LinkedList<TreeNode> current = new LinkedList<TreeNode>();
        if(root!= null) {
        //add the root in the first linked list
            current.add(root);
        }
        while(current.size() > 0) { ////termination condition, size will be 0 after visiting leaves 
            result.add(current);
            LinkedList<TreeNode> parents = current; //save current to iterate through its children
            current = new LinkedList<TreeNode>(); //new empty linked list current
            for( TreeNode parent: parents) {
                if(parent.left!=null) {
                    current.add(parent.left);
                }
                if(parent.right!=null) {
                    current.add(parent.right);
                }
            }
        }
        return result;
  }
  
  
    public static void main(String[] args) {
        Tree t1 = new Tree();
        int[] a = {1,2,3,4,5};
        TreeNode r = t1.createMinimalTree(a);
        t1.inOrder(r);
    }
}
