public class Tree {

/*Minimal Tree: Given a sorted (increasing order) array with unique integer elements, write an
algorithm to create a binary search tree with minimal height.

leetcode: Convert Sorted Array to Binary Search Tree 

O(n) space, O(n) time */

 public TreeNode createMinimalTree(int[] arr) {
       return createMinimalTree(arr, 0, arr.length-1);

    }

    public TreeNode createMinimalTree(int[] arr, int low, int high) {
        if(low>high) {
            return null;
        }
        int mid = (high+low)/2;
        TreeNode n = new TreeNode(arr[mid]);
        n.left = createMinimalTree(arr, low, mid-1);
        n.right = createMinimalTree(arr, mid+1, high);
        return n;
    }
    
    
/*Given a binary tree, design an algorithm which creates a linked list of all the nodes
at each depth*/

public ArrayList<LinkedList<TreeNode>> linkedListForDepth() {
        ArrayList<LinkedList<TreeNode>> result =new ArrayList<LinkedList<TreeNode>>();
        LinkedList<TreeNode> current = new LinkedList<TreeNode>();
        if(root!= null) {
        //add the root in the first linked list
            current.add(root);
        }
        while(current.size() > 0) { ////termination condition, size will be 0 after visiting leaves 
            result.add(current);
            LinkedList<TreeNode> parents = current; //save current to iterate through its children
            current = new LinkedList<TreeNode>(); //new empty linked list current
            for( TreeNode parent: parents) {
                if(parent.left!=null) {
                    current.add(parent.left);
                }
                if(parent.right!=null) {
                    current.add(parent.right);
                }
            }
        }
        return result;
  }
  
  /*Check Balanced: Implement a function to check if a binary tree is balanced. For the purposes of
this question, a balanced tree is defined to be a tree such that the heights of the two subtrees of any
node never differ by more than one.*/

public int getHeight(TreeNode root) {
       if(root == null) { //Base case
           return -1;
       }
        return Math.max(getHeight(root.left),getHeight(root.right))+1;
    }

    public boolean isBalanced(TreeNode root) {
        if(root == null) { //Base case
            return true;
        }
        int heightDiff = getHeight(root.left) - getHeight(root.right);
        if(Math.abs(heightDiff) > 1) {
            return false;
        }else { //Recurse
            return (isBalanced(root.left) && isBalanced(root.right));
        }
    }
  
  
    public static void main(String[] args) {
        Tree t1 = new Tree();
        int[] a = {1,2,3,4,5};
        TreeNode r = t1.createMinimalTree(a);
        t1.inOrder(r);
    }
}
